---
title: "flat_linking_inputs.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
library(here)
library(tibble)
library(DT)
```

```{r}
library(here)
library(tibble)
library(dplyr)
library(DT)
```

# link_inputs

```{r development-link_inputs}
# Prepare the code of your function here
```

```{r function-link_inputs}
#' Symlink Google Drive Data Space to Local Data Directory
#'
#' This function creates a symbolic link from a Google Drive data space (specified in a config file)
#' to a local "data" directory. It checks for the existence of the Google Drive path and the local
#' data directory, creates the local directory if it does not exist, and then creates the symlink.
#'
#' @param cfg_path Character. Path to the configuration file containing the Google Drive data space path.
#'
#' @return Logical. Returns TRUE if the linking is successful; otherwise, stops with an error.
#'
#' @examples
#' \dontrun{
#' link_inputs("config.yml")
#' }
#' 
#' @export
link_inputs <- function(cfg_path) {

  cfg <- config::get(file = cfg_path)
  gdrive_path <- cfg$gdrive_path
  if (is.null(gdrive_path)) {
    stop("Please provide the path to the google drive data space in the config file")
  }
  if (!dir.exists(gdrive_path)) {
    stop(paste0("The provided gdrive_path does not exist: ", gdrive_path))
  }

  # this is what makes the pipeline portable across systems
  local_data_dir <- here::here("data")
  if (!dir.exists(local_data_dir)) {
    dir.create(local_data_dir)
  }
  
  message(paste0("Linking the google drive data space to the local Data directory: ", gdrive_path))
  file.symlink(gdrive_path, local_data_dir)

  if (dir.exists(file.path(local_data_dir, basename(gdrive_path)))) {
    message("Linking successful!")
  } else {
    stop("Linking failed!")
  }  

  # return the full file tree of the linked data directory with full paths
  files <- list.files(local_data_dir, recursive = TRUE, full.names = TRUE, include.dirs = TRUE)

  files

}
```

```{r examples-link_inputs}
link_inputs("config.yml")
```

```{r tests-link_inputs}
test_that("link_inputs works", {
  expect_true(inherits(link_inputs, "function"))
})
```


# list_raw_gps_dhs

Our DHS data contains GPS files for certain survey years. This function catalogs and fetches the paths to those files.
We recognize that the GPS files follow a specific naming pattern, typically starting with "MDGE" followed by the survey year and ending with "FL.shp".
    
```{r development-list_raw_gps_dhs}
# You can prepare the code of the list_raw_gps() function here
```
  
```{r function-list_raw_gps_dhs}
#' Title
#' 
#' Ingest the list of files in the project and return those that are GPS DHS files
#' 
#' @param file_list Character vector of file paths to check.
#'
#' @return Character vector of GPS DHS file paths.
#' @importFrom here here
#' @export
list_raw_gps_dhs <- function(file_list){

  # Filter the file list to include only GPS DHS files
  gps_files <- stringr::str_subset(file_list, "MDGE[0-9]{2}FL.shp$")

  return(gps_files)
}
```
  
```{r example-list_raw_gps}
link_inputs("config.yml") %>%
  list_raw_gps_dhs()
```
  
```{r tests-list_raw_gps_dhs}
test_that("list_raw_gps_dhs works", {
  expect_true(inherits(list_raw_gps_dhs, "function")) 
})
```
  
# list_raw_flat_dhs

The flat DHS recode files we have in our data repository are cataloged and fetched by this function.
This is the bulk of the DHS data we have, spanning multiple survey years and recode types.
This function returns a character vector of file paths to the flat DHS recode files.
    
```{r development-list_raw_flat_dhs}
# You can prepare the code of the list_raw_flat_dhs() function here
```
  
```{r function-list_raw_flat_dhs}
#' Title
#' 
#' Ingest the list of files in the project and return those that are flat DHS recode files
#' 
#' @param file_list Character vector of file paths to check.
#' @return Character vector of flat DHS recode file paths.
#' @export
list_raw_flat_dhs <- function(file_list){
    
  # Filter the file list to include only flat DHS recode files
  flat_dhs_files <- stringr::str_subset(file_list, "MD(?:BR|HR|IR|PR|KR|CR|SQ|WI|MR|HW|FW)[0-9]{2}FL$")

  return(flat_dhs_files)
}
```
  
```{r example-list_raw_flat_dhs}
link_inputs("config.yml") %>%
  list_raw_flat_dhs()
```
  
```{r tests-list_raw_flat_dhs}
test_that("list_raw_flat_dhs works", {
  expect_true(inherits(list_raw_flat_dhs, "function")) 
})
```

The summary of current DHS survey files we have is as follows:

```{r}
library(DT)

survey_summary <- data.frame(
  Year       = c("1992", "1997", "2003-04", "2008-09", "2021"),
  BR         = c(1, 1, 1, 1, 1),
  HW         = c(1, 1, 1, 0, 0),
  CR         = c(0, 0, 1, 1, 1),
  HR         = c(1, 1, 1, 1, 1),
  IR         = c(1, 1, 1, 1, 1),
  KR         = c(1, 1, 1, 1, 1),
  PR         = c(1, 1, 1, 1, 1),
  WI         = c(0, 1, 0, 0, 0),
  SQ         = c(1, 0, 0, 0, 0),
  MR         = c(0, 0, 1, 1, 1),
  FW         = c(0, 0, 0, 0, 1),
  stringsAsFactors = FALSE
)

datatable(survey_summary)
```

# list_raw_gps_covars

This catalogs and fetches the paths to the covariate files for GPS data.
    
```{r development-list_raw_gps_covars}
# You can prepare the code of the list_raw_gps_covars() function here
```
  
```{r function-list_raw_gps_covars}
#' Title
#' 
#' Description
#' 
#' @return
#' @importFrom purrr map_chr
#' @importFrom here here
#' @export
list_raw_gps_covars <- function(file_list){
    
    gps_covars <- stringr::str_subset(file_list, "MDGC[0-9]{2}FL.csv$")
    return(gps_covars)
}
```
  
```{r example-list_raw_gps_covars}
link_inputs("config.yml") %>%
  list_raw_gps_covars()
```
  
```{r tests-list_raw_gps_covars}
test_that("list_raw_gps_covars works", {
  expect_true(inherits(list_raw_gps_covars, "function")) 
})
```

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_linking_inputs.Rmd", vignette_name = "Linking and Tracking Raw Inputs", open_vignette = FALSE, check = FALSE)
```

