---
title: "flat_load_flat_dhs_data.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
library(here)
library(tidyverse)
library(purrr)
library(rdhs)
library(glue)
```

Here we demonstrate how to load and view the DHS datasets that will be
harmonized in this package. Each section builds the function needed
to read in the data, and then tests it to ensure it works as expected.
The functions are then implemented in the targets pipeline.

Some basic EDA is provided for you to help you understand what data
can be made available to you through a data request.

```{r}
library(targets)
library(here)
library(tidyverse)
library(purrr)
library(rdhs)
library(glue)
library(sf)
```

## load_flat_dhs_data

So long as the data has a flat structure, it should be straightforward to
load it into R and view it using the `rdhs` package. The structure is taken from
this [DHS page](https://dhsprogram.com/data/File-Types-and-Names.cfm#CP_JUMP_10334).

```
Example:
To give an example of how distribution files for a survey are organized, the following table shows the available files, along with the names that they are given for the Kenya 2003 DHS survey.
Kenya 2003 DHS Survey
 	ASCII File Types	Software-Specific Data File Types
Unit of Analysis	Hierarchical	Flat	SAS	SPSS	Stata
Households	 	KEHR42FL.ZIP	KEHR42SD.ZIP	KEHR42SV.ZIP	KEHR42DT.ZIP
Household Members	 	KEPR42FL.ZIP	KEPR42SD.ZIP	KEPR42SV.ZIP	KEPR42DT.ZIP
Women	KEIR42.ZIP	KEIR42FL.ZIP	KEIR42SD.ZIP	KEIR42SV.ZIP	KEIR42DT.ZIP
Men	KEMR42.ZIP	KEMR42FL.ZIP	KEMR42SD.ZIP	KEMR42SV.ZIP	KEMR42DT.ZIP
Births	 	KEBR42FL.ZIP	KEBR42SD.ZIP	KEBR42SV.ZIP	KEBR42DT.ZIP
Children	 	KEKR42FL.ZIP	KEKR42SD.ZIP	KEKR42SV.ZIP	KEKR42DT.ZIP
Couples	 	KECR42FL.ZIP	KECR42SD.ZIP	KECR42SV.ZIP	KECR42DT.ZIP
HIV Test Results	KEAR42.ZIP	KEAR42FL.ZIP	KEAR42SD.ZIP	KEAR42SV.ZIP	KEAR42DT.ZIP

The following reference tables contain the descriptions for the four different types of filename codes (country, data type, data version, and file format).

```

In our case, we have the following:

```
tree -L 3 data/DHS\ Data/
```

```
data/DHS Data/
├── DHS 1992
│   ├── MDBR21FL
│   │   ├── MDBR21FL.DAT
│   │   ├── MDBR21FL.DCF
│   │   ├── MDBR21FL.DCT
│   │   ├── MDBR21FL.DO
│   │   ├── MDBR21FL.frq
│   │   ├── MDBR21FL.frw
│   │   ├── MDBR21FL.MAP
│   │   ├── MDBR21FL.SAS
│   │   └── MDBR21FL.SPS
│   ├── MDHR21FL
│   │   ├── MDHR21FL.DAT
│   │   ├── MDHR21FL.DCT
│   │   ├── MDHR21FL.DO
│   │   ├── MDHR21FL.FRQ
│   │   ├── MDHR21FL.FRW
│   │   ├── MDHR21FL.MAP
│   │   ├── MDHR21FL.SAS
│   │   └── MDHR21FL.SPS
│   ├── MDHW21FL
│   │   ├── MDHW21FL.DAT
│   │   ├── MDHW21FL.DCF
│   │   ├── MDHW21FL.DCT
│   │   ├── MDHW21FL.DO
│   │   ├── MDHW21FL.MAP
│   │   ├── MDHW21FL.SAS
│   │   ├── MDHW21FL.SPS
│   │   └── MERGE.DOC
│   ├── MDIR21FL
│   │   ├── MDIR21FL.DAT
│   │   ├── MDIR21FL.DCT
│   │   ├── MDIR21FL.DO
│   │   ├── MDIR21FL.DOC
│   │   ├── MDIR21FL.FRQ
│   │   ├── MDIR21FL.FRW
│   │   ├── MDIR21FL.MAP
│   │   ├── MDIR21FL.SAS
│   │   └── MDIR21FL.SPS
│   ├── MDKR21FL
│   │   ├── MDKR21FL.DAT
│   │   ├── MDKR21FL.DCT
│   │   ├── MDKR21FL.DO
│   │   ├── MDKR21FL.DOC
│   │   ├── MDKR21FL.FRQ
│   │   ├── MDKR21FL.MAP
│   │   ├── MDKR21FL.SAS
│   │   └── MDKR21FL.SPS
│   ├── MDPR21FL
│   │   ├── MDPR21FL.DAT
│   │   ├── MDPR21FL.DCT
│   │   ├── MDPR21FL.DO
│   │   ├── MDPR21FL.FRQ
│   │   ├── MDPR21FL.FRW
│   │   ├── MDPR21FL.MAP
│   │   ├── MDPR21FL.SAS
│   │   └── MDPR21FL.SPS
│   └── MDSQ21FL
│       ├── MDSQ21FL.DAT
│       ├── MDSQ21FL.DCT
│       ├── MDSQ21FL.DO
│       ├── MDSQ21FL.MAP
│       ├── MDSQ21FL.SAS
│       └── MDSQ21FL.SPS
```

So, for the generic ones, we know that we have BR (Birth rates), HR (Household), HW (height and weight), IR (individual),
KR (kids), PR (household member), and SQ (Service Availability). We also have WI (wealth), CR (couples), MR (men's), 
GE (Geographic Data), GC (geospatial covariates), FW (Fieldworker), and MIS data (malaria response survey).

To read in the generic flat files, we can use the `rdhs` package. This has to be done by first zipping
the files to a temporary location, and then using the `rdhs::read_flat()` function.

```{r}
library(rdhs)
library(dplyr)
library(here)
library(zip)

ex_data <- here("data", "DHS Data", "DHS 1992", "MDIR21FL")
temp_zip <- tempfile(fileext = ".zip")

zip::zipr(zipfile = temp_zip, files = list.files(ex_data, full.names = TRUE))
file.exists(temp_zip)
```

```{r}
dhs_data <- rdhs:::read_dhs_flat(temp_zip)
tibble(dhs_data)
```

We can see that the variables do come with labels and attributes. This is
useful information for understanding the data.

```{r}
get_variable_labels(dhs_data) %>%
  head()
```

So, to read in a generic flat file from DHS, we can define the function `load_flat_dhs_data()`:

```{r development-load_flat_dhs_data}
# Prepare the code of your function here
```

```{r function-load_flat_dhs_data}
#' load_flat_dhs_data Title
#'
#' @return 1
#' @export
#'
#' @examples
load_flat_dhs_data <- function(folder_path) {
  
  temp_zip <- tempfile(fileext = ".zip")
  zip::zipr(zipfile = temp_zip, files = list.files(folder_path, full.names = TRUE))
  dhs_data <- rdhs:::read_dhs_flat(temp_zip)
  return(dhs_data)

}
```

```{r examples-load_flat_dhs_data}
ex_data <- here("data", "DHS Data", "DHS 1992", "MDIR21FL")
load_flat_dhs_data(ex_data) %>%
  tibble() %>%
  head()
```

```{r tests-load_flat_dhs_data}
test_that("load_flat_dhs_data works", {
  expect_true(inherits(load_flat_dhs_data, "function"))
})
```

We can also test that this works for the malaria response survey data:

```{r}
ex_data <- here("data", "DHS Data", "MIS 2016", "MDIR71FL")

load_flat_dhs_data(ex_data) %>%
  tibble() %>%
  head()
```

Because the different kinds of surveys have different variable
structures, we will read each type separately.

To do this, we'll read in a list of file paths,
and then map over them to read them in.

In the targets pipeline, we've assigned the BR files to
a target called `dhs_data_BR`, which has multiple branches for
each file path.

```{r}
tar_read(dhs_data_BR, branches = 1, store = here("_targets")) -> ex_data_1
tar_read(dhs_data_BR, branches = 5, store = here("_targets")) -> ex_data_2

tibble(ex_data_1[[1]])
```

```{r}
tibble(ex_data_2[[1]])
```

So even though they come from the same type of survey,
the variables are different and cannot be easily merged with
the `rhds::rbind_labelled()` function, because they change year over year:

```{r, error=TRUE}
# try to merge all of the BR datasets
all_br_data <- tar_read(dhs_data_BR, store = here("_targets"))
tryCatch({
  rdhs::rbind_labelled(all_br_data) %>% tibble()
}, error = function(e) {
  message("Error merging BR datasets: ", e$message)
  NULL
})
```

So with that in mind, we should take a look at the actual
variable dictionaries for each survey type to plan how we will
eventually harmonize and release them (descriptions are provided
by ChatGPT and verified with DHS documentation available [here](https://preview.dhsprogram.com/pubs/pdf/DHSG1/Guide_to_DHS_Statistics_DHS-7_v2.pdf)).

## summarize_dhs_flat_dictionary

The function `summarize_dhs_flat_dictionary()` will read in all of the flat files of a given survey type (e.g., BR, HR, IR)
and summarize the variable names.

```{r development-summarize_dhs_flat_dictionary}
# You can prepare the code of the summarize_dhs_flat_dictionary() function here
```
  
```{r function-summarize_dhs_flat_dictionary}
#' Title
#' 
#' Description
#' 
#' @return
#' 
#' @export
summarize_dhs_flat_dictionary <- function(all_survey_data){
  
  n_surveys <- length(all_survey_data) # shows the number of branches   

  map(
    all_survey_data,
    ~ get_variable_labels(.x) %>%
      as_tibble()
    ) %>%
    list_rbind() %>%
    group_by(description, variable) %>%
    summarise(
      description = first(description),
      n = n()
    ) %>%
    arrange(-n) -> var_descriptions

  return(var_descriptions)
}
```
  
```{r tests-summarize_dhs_flat_dictionary}
test_that("summarize_dhs_flat_dictionary works", {
  expect_true(inherits(summarize_dhs_flat_dictionary, "function")) 
})
```
  

### Birth Recode Variables

> A dataset where each record represents a live birth to a surveyed woman. It is used primarily for fertility and mortality analyses (e.g., age‐specific fertility rates, infant/child mortality) by linking births to the mother’s survey responses.

```{r}
survey_data <- tar_read(dhs_data_BR, store = here("_targets"))
var_descriptions_br <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_BR, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_br, caption = glue("Variable Descriptions for Birth Recode Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Couples Recode Variables

> A dataset where each record is a couple (husband + wife) interviewed in the survey. Used for analyses of spousal/partner characteristics, family planning dynamics, and household reproduction.

```{r}
survey_data <- tar_read(dhs_data_CR, store = here("_targets"))
var_descriptions_cr <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_CR, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_cr, caption = glue("Variable Descriptions for Couples Recode Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Height/Weight Variables

> A dataset focusing on anthropometric measurements for children under age 5 (height/length, weight, nutritional status z-scores) designed to support child nutrition and growth‐monitoring analyses.  

```{r}
survey_data <- tar_read(dhs_data_HW, store = here("_targets"))
var_descriptions_hw <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_HW, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_hw, caption = glue("Variable Descriptions for Height/Weight Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Household Recode Variables

> A dataset in which each record is a household. It contains information on household structure, living conditions, assets, water/sanitation, and biomarkers for household members. Useful for household‐level analysis and linking to individual recodes

```{r}
survey_data <- tar_read(dhs_data_HR, store = here("_targets"))
var_descriptions_hr <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_HR, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_hr, caption = glue("Variable Descriptions for Household Recode Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Individual Recode (Women) Variables

> A dataset with one record per interviewed woman (usually ages 15-49). Contains their birth histories, reproductive health, contraceptive use, maternity care, and child health modules. It is the primary unit for women’s health and fertility research.

```{r}
survey_data <- tar_read(dhs_data_IR, store = here("_targets"))
var_descriptions_ir <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_IR, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_ir, caption = glue("Variable Descriptions for Individual Recode (Women) Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Kids Recode Variables

> A dataset with one record per child under age 5 born to a surveyed woman. It includes immunization, illness episodes, nutrition, growth, and survival status for each child.

```{r}
survey_data <- tar_read(dhs_data_KR, store = here("_targets"))
var_descriptions_kr <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_KR, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_kr, caption = glue("Variable Descriptions for Kids Recode Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Household Member Recode Variables

> A dataset with one record per household member (both male and female) in the selected households. Contains demographic, socio‐economic, and biomarker information. Useful for analyses of all household members—not just women or children.

```{r}
survey_data <- tar_read(dhs_data_PR, store = here("_targets"))
var_descriptions_pr <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_PR, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_pr, caption = glue("Variable Descriptions for Household Member Recode Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Wealth Index Variables

> An optional dataset (in older surveys) where each record is a household and it specifically provides wealth score and quintile for that survey, used when wealth index was not yet integrated in other recode files.

```{r}
survey_data <- tar_read(dhs_data_WI, store = here("_targets"))
var_descriptions_wi <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_WI, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_wi, caption = glue("Variable Descriptions for Wealth Index Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Men's Recode Variables

> A dataset where each record is an interviewed man (often ages 15-59). It includes his fertility, contraception, HIV/AIDS, and health‐behavior modules. Useful for research on men’s health and reproductive behavior. 

```{r}
survey_data <- tar_read(dhs_data_MR, store = here("_targets"))
var_descriptions_mr <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_MR, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_mr, caption = glue("Variable Descriptions for Men's Recode Surveys ({n_surveys} Distinct Surveys Total)"))
```

### Fieldworker Variables

> A dataset with one record for each fieldworker/interviewer in the survey. It contains characteristics of data collection staff (age, education, languages, prior experience), used for survey‐quality and interviewer bias analyses

```{r}
survey_data <- tar_read(dhs_data_FW, store = here("_targets"))
var_descriptions_fw <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_FW, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_fw, caption = glue("Variable Descriptions for Fieldworker Surveys ({n_surveys} Distinct Surveys Total)"))
```


### Supplemental Questionnaire Variables

> A file type associated with additional modules or supplemental questionnaires (e.g., field worker interviews, special modules) beyond the core recode files. Use is more specialized depending on the country/survey. 

```{r}
survey_data <- tar_read(dhs_data_SQ, store = here("_targets"))
var_descriptions_sq <- summarize_dhs_flat_dictionary(survey_data)
n_surveys <- length(tar_read(dhs_data_SQ, store = here("_targets"))) # shows the number of branches
DT::datatable(var_descriptions_sq, caption = glue("Variable Descriptions for Supplemental Questionnaire Surveys ({n_surveys} Distinct Surveys Total)"))
```


## load_gps_dhs_data

Reading in the geospatial data is a little bit different:

```{r}
ex_data <- here("data", "DHS Data", "DHS 1997", "GPS Data", "MDGE32FL")
list.files(ex_data)
```

To read in shapefiles, we can use the `sf` package:

```{r}
library(sf)
gps_data <- sf::st_read(dsn = ex_data)
gps_data
```

We can plot the data as well:

```{r}
plot(st_geometry(gps_data))
```


### What Geospatial Data Do we have?

Let's do some simple EDA of the geospatial data to understand what we have.

From the manual:

> In most recent DHS surveys, the groupings of households that participated in the survey, known as clusters, are geo referenced.  These survey cluster coordinates are collected in the field using GPS receivers, usually during the survey sample listing process. In general, the GPS readings for most clusters are accurate to less than 15 meters.

So a DHS cluster is a group of households surveyed at a given location.

We have the following number of years of GPS surveys:

```{r}
gps_data <- tar_read(gps_data, store = here("_targets"))
length(gps_data)
```

This tells us how many unique clusters (features, in the sf df) we have across each year:

```{r}
map(
  gps_data,
  ~ .x %>%
    select(DHSID, DHSYEAR) %>%
    distinct()
)
```

There's a weird data point in the data that is far outside of Madagascar.

Let's remove this:

```{r}
map(
  gps_data,
  ~ .x %>%
    select(LATNUM, LONGNUM) %>%
    summary()
)
```

The data point at 0-0 is clearly an error. Let's remove any
points with latitudes or longitudes equal to 0.

```{r}
gps_data2 <- map(
  gps_data,
  ~ .x %>%
    filter(LATNUM != 0 & LONGNUM != 0)
)
```

Now, what is the overlap of our clusters with our Madagascar healthsheds? To do this, we will
perform a spatial join between the GPS points and the healthshed polygons.

Fetching our healthsheds:

```{r}
healthsheds <- st_read(here("sandbox", "mdg_healthsheds2022", "healthsheds2022.shp"))
```

Ensure both datasets use the same coordinate reference system (CRS):
```{r}
map(
  gps_data2,
  ~ st_crs(.x)
)
```

```{r}
st_crs(healthsheds) == st_crs(gps_data2[[1]])
```

Here's what the healthsheds look like:

```{r}
ggplot(healthsheds) +
  geom_sf(aes(fill = fs_pop))
```

What we want to know: Our healthsheds represent areas of healthcare access.
Any analysis that we want to think about should be done with respect to these
areas, so that we can know how different variables relate to "healthcare access".

So, we want to know how many survey clusters fall within each healthshed. To do this,
we should do a spatial join between the GPS points and the healthshed polygons, where the
goal is to know how many GPS points fall within each healthshed.

At first, this may not look to be very successful because the surveys are relatively sparse:

```{r}
bind_rows(gps_data2) %>%
  ggplot() +
  geom_sf() +
  facet_grid(~ DHSYEAR)
```

So we need to figure out the degree of overlap between the GPS points and the healthsheds.

```{r}
# Spatial join: assign each GPS point to a healthshed polygon
# st_intersects means we are looking for points in the DHS that overlap on the healthshed polygons
pts <- gps_data2[[1]]
joined <- st_join(healthsheds, pts, left = TRUE, join = st_intersects)
```

```{r}
joined %>%
  st_drop_geometry() %>% 
  group_by(fs_uid, fs_name) %>%
  # how many DHSIDs are in each fs_uid
  summarise(n_points = n_distinct(DHSID, na.rm = TRUE), .groups = "drop") -> summary_counts

DT::datatable(summary_counts)
```

Most of the healthsheds have zero GPS points overlapping them, but at most there are 11.
Let's visualize these for one year:

```{r}
summary_counts %>%
  left_join(healthsheds, ., by = c("fs_uid", "fs_name")) %>%
  ggplot() +
  geom_sf(aes(fill = n_points)) +
  scale_fill_viridis_c(option = "plasma", na.value = "grey90") +
  theme_minimal() +
  labs(fill = "# GPS points")
```

With the same strategy, we can plot all of the years:

```{r}
map(
  gps_data2,
  function(x) {
    year <- unique(x$DHSYEAR)
    pts <- x
    joined <- st_join(pts, healthsheds, left = FALSE)
    summary_counts <- joined %>% 
      st_drop_geometry() %>%
      group_by(fs_uid, fs_name) %>% 
      summarise(n_points = n(), .groups = "drop") %>%
      mutate(DHSYEAR = year)

    return(summary_counts)

  }
) %>%
  list_rbind() %>%
  left_join(healthsheds, ., by = c("fs_uid", "fs_name")) %>%
  ggplot() +
  geom_sf(aes(fill = n_points)) +
  scale_fill_viridis_c(option = "plasma", na.value = "grey90") +
  theme_minimal() +
  labs(fill = "# GPS points") +
  facet_wrap(DHSYEAR ~ ., nrow=2)
```

You may notice that the join created more rows than the original healthsheds. This
is because healthsheds are not mutually exclusive (topologically disjoint) and have some overlap:

```{r}
# st_intersects shows indeces of healthsheds with overlaps; the fact that
# some have lengths > 1 indicates overlap
lengths(st_intersects(healthsheds))
```

This is important to note for future analyses.

## load_gps_covars

There's a covariate file that comes with the GPS data as well.

```{r}
ex_data <- here("data", "DHS Data", "DHS 1997", "GPS Data", "MDGC32FL") %>%
  list.files(full.names = TRUE) %>%
  grep(pattern = "csv$", value = TRUE)
ex_data
```

```{r}
library(readr)
library(skimr)

gps_covars <- read_csv(ex_data)
skim(gps_covars)
```

Interestingly, there is data from many years included, even though
the folder is for 1997. From ChatGPT:


> The geospatial covariates provided with DHS GPS data (e.g., Annual_Precipitation_2000, Day_Land_Surface_Temp_2010) come from external environmental and remote-sensing datasets, not from the DHS survey itself.
> The year indicated in each variable name (e.g., _2000, _2005, _2010, _2015) refers to the reference year of the underlying satellite or modeled dataset, not the year when the DHS survey was conducted.
> These layers are standardized across all DHS surveys so users can compare environmental conditions over time or across countries. For a given survey, analysts typically use covariates from the year closest to the survey year (e.g., use 2000 data for a 1997 survey).

In short:

DHSYEAR = when the survey happened
Variable suffix (e.g., _2000) = when the environmental data were measured

Even when two DHS surveys include covariates with the same reference year (e.g., Annual_Precipitation_2000), the values will differ because each survey’s clusters are unique. The covariate year indicates the year of the environmental dataset, not that the same locations or values are shared across surveys.

To clean this, we'll also need to acknowledge that NA is represented by -9999.
It looks like all of the covariates are numeric except for DHSCLUST, which is the cluster ID.

```{r development-load_gps_covars}
# You can prepare the code of the load_gps_covars() function here
```
  
```{r function-load_gps_covars}
#' Title
#' 
#' Description
#' 
#' @return
#' 
#' @export
load_gps_covars <- function(fpath, factor_vars = c("DHSCLUST", "DHSID", "DHSCC", "GPS_Dataset")) {
  
  gps_covars <- readr::read_csv(fpath, na = c("", "NA", "-9999")) %>%
    dplyr::mutate(dplyr::across(dplyr::all_of(factor_vars), as.factor)) %>%
    dplyr::mutate(dplyr::across(where(is.character), as.factor))
  
  return(gps_covars)
}
```
  
```{r example-load_gps_covars}
ex_data <- here("data", "DHS Data", "DHS 1997", "GPS Data", "MDGC32FL") %>%
  list.files(full.names = TRUE) %>%
  grep(pattern = "csv$", value = TRUE)
load_gps_covars(ex_data) %>%
  skimr::skim()
```
  
```{r tests-load_gps_covars}
test_that("load_gps_covars works", {
  expect_true(inherits(load_gps_covars, "function")) 
})
```

So what covariate data do we have?

```{r}
gps_covar_data <- tar_read(gps_covar_data, store = here("_targets"))
```

GPS covars cover the following number of years:

```{r}
length(gps_covar_data)
```

This is fairly easy to summarize:

```{r}
list_rbind(gps_covar_data) %>%
  group_by(DHSYEAR) %>%
  skimr::skim()
```

## Conclusion

The DHS harmonization package provides methods to read in flat DHS data files,
GPS data files, and GPS covariate files. These functions are used to provide
an initial targets pipeline that reads in all of the relevant data for Madagascar DHS surveys.

To get a harmonized dataset, reach out to Tinashe on Github and provide a data request,
and we can work on harmonizing the datasets for your use case. The harmonized dataset will
be made available through a targets endpoint in the package that you can load into your R session.

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_load_dhs_data.Rmd", vignette_name = "Reading in Files from DHS", open_vignette = FALSE, check = FALSE)
```

